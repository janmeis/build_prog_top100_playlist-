import os
import csv
import shutil
import argparse
import re
from typing import Optional, Tuple, Dict, Set

INVALID_WIN_CHARS = set('<>:"/\\|?*')
TRAILING_BAD = re.compile(r'[ .]+$')
MULTI_SPACE = re.compile(r'\s{2,}')


def sanitize_component(name: str) -> str:
    # Remove characters invalid on Windows and trim trailing dots/spaces
    cleaned = ''.join(ch for ch in name if ch not in INVALID_WIN_CHARS)
    cleaned = cleaned.replace('\u200b', '')  # zero-width space, just in case
    cleaned = MULTI_SPACE.sub(' ', cleaned).strip()
    cleaned = TRAILING_BAD.sub('', cleaned)
    return cleaned


def build_folder_name(artist: str, album: str, year: str) -> str:
    artist_s = sanitize_component(artist)
    album_s = sanitize_component(album)
    year_s = year.strip()
    if year_s:
        return f"{artist_s} - {year_s} - {album_s}"
    else:
        return f"{artist_s} - {album_s}"


def parse_row(row: Dict[str, str]) -> Tuple[str, str, str, str]:
    # Expect header: path, artist, album, year
    path = (row.get('path') or '').strip()
    artist = (row.get('artist') or '').strip()
    album = (row.get('album') or '').strip()
    year = (row.get('year') or '').strip()
    return path, artist, album, year


def read_csv_rows(csv_path: str) -> Tuple[Set[Tuple[str, str, str]], Dict[Tuple[str, str, str], str]]:
    unique_keys: Set[Tuple[str, str, str]] = set()
    src_map: Dict[Tuple[str, str, str], str] = {}

    with open(csv_path, 'r', encoding='utf-8-sig', newline='') as f:
        # Try reading as DictReader using expected headers; fallback to basic reader
        sample = f.read(2048)
        f.seek(0)
        has_header = 'path;artist;album;year' in sample.replace('\r', '').lower()
        if has_header:
            reader = csv.DictReader(f, delimiter=';')
            for row in reader:
                path, artist, album, year = parse_row(row)
                if not path:
                    continue
                src_dir = path.rstrip('\\/')
                key = (artist, year, album)
                if key not in unique_keys:
                    unique_keys.add(key)
                    src_map[key] = src_dir
        else:
            reader = csv.reader(f, delimiter=';')
            for fields in reader:
                if len(fields) < 3:
                    continue
                # Assume order path;artist;album;year (year optional)
                path = (fields[0] or '').strip()
                artist = (fields[1] or '').strip()
                album = (fields[2] or '').strip()
                year = (fields[3] or '').strip() if len(fields) > 3 else ''
                if not path:
                    continue
                src_dir = path.rstrip('\\/')
                key = (artist, year, album)
                if key not in unique_keys:
                    unique_keys.add(key)
                    src_map[key] = src_dir

    return unique_keys, src_map


def copy_album(src_dir: str, dest_dir: str, overwrite: bool = False) -> None:
    if overwrite and os.path.exists(dest_dir):
        shutil.rmtree(dest_dir)
    os.makedirs(dest_dir, exist_ok=True)
    # Copy all files and subfolders from src_dir into dest_dir
    for root, dirs, files in os.walk(src_dir):
        rel = os.path.relpath(root, src_dir)
        target_root = dest_dir if rel == '.' else os.path.join(dest_dir, rel)
        os.makedirs(target_root, exist_ok=True)
        for d in dirs:
            os.makedirs(os.path.join(target_root, d), exist_ok=True)
        for fn in files:
            src_file = os.path.join(root, fn)
            dst_file = os.path.join(target_root, fn)
            shutil.copy2(src_file, dst_file)


def main():
    ap = argparse.ArgumentParser(description='Copy album folders listed in CSV to a destination flattened as "Artist - Year - Album".')
    ap.add_argument('csv', help='CSV file generated by playlist_to_csv.py (semicolon-delimited, UTF-8).')
    ap.add_argument('dest', help='Destination base folder to copy into.')
    ap.add_argument('--overwrite', action='store_true', help='Overwrite existing destination album folders.')
    ap.add_argument('--skip-existing', action='store_true', help='Skip albums that already exist at destination (default if neither overwrite nor skip specified: skip).')
    ap.add_argument('--dry-run', action='store_true', help='Print planned operations without copying.')
    args = ap.parse_args()

    csv_path = args.csv
    dest_base = args.dest.rstrip('\\/')

    unique_keys, src_map = read_csv_rows(csv_path)

    planned = []
    for key in unique_keys:
        artist, year, album = key
        src_dir = src_map[key]
        folder_name = build_folder_name(artist, album, year)
        dest_dir = os.path.join(dest_base, folder_name)
        planned.append((src_dir, dest_dir))

    # Execute plan
    for src_dir, dest_dir in planned:
        exists = os.path.exists(dest_dir)
        action = 'copy'
        if exists and not args.overwrite:
            action = 'skip'
        elif exists and args.overwrite:
            action = 'overwrite'

        print(f"{action.upper()}: {src_dir} -> {dest_dir}")
        if args.dry_run:
            continue
        if action == 'skip':
            continue
        copy_album(src_dir, dest_dir, overwrite=args.overwrite)

    print('Done.')


if __name__ == '__main__':
    main()
